{"version":3,"sources":["../../src/helper/vectorStore.ts"],"sourcesContent":["// import { GSContext, GSStatus, PlainObject } from \"@godspeedsystems/core\";\r\nimport { IndexFlatL2 } from 'faiss-node';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport  { GoogleGenerativeAIEmbeddings } from \"@langchain/google-genai\";\r\nconsole.log(\"Loaded @langchain/google-genai\");\r\n// import { chunkText } from './utils'; // Ensure you include utils.ts in your Godspeed project\r\n// import crypto from 'crypto';\r\n// import { fileURLToPath } from 'url';\r\n\r\n// const __filename = fileURLToPath(import.meta.url);\r\n// const __dirname = path.dirname(__filename);\r\n// dotenv.config({ path: path.resolve(__dirname, '../../.env') });\r\n// const indexPath='../../index/index.faiss';\r\n// const metaPath='../../index/metadata.json';\r\n// const docIdMapPath='../../index/docIdMap.json';\r\n\r\ninterface Metadata {\r\n  [docId: string]: {\r\n    content: string;\r\n  };\r\n}\r\n\r\nexport class VectorStore {\r\n  private indexPath: string;\r\n  private metaPath: string;\r\n  private docIdMapPath: string;\r\n  private model: GoogleGenerativeAIEmbeddings;\r\n  private index: IndexFlatL2;\r\n  private metadata: Metadata = {};\r\n  private docIdByVectorIdx: string[] = [];\r\n\r\n  constructor(\r\n    indexPath = path.resolve(__dirname, '../../index/index.faiss'),\r\n    metaPath = path.resolve(__dirname, '../../index/metadata.json'),\r\n    docIdMapPath = path.resolve(__dirname, '../../index/docIdMap.json')\r\n  ){\r\n    const apiKey = process.env.GOOGLE_API_KEY;\r\n    if (!apiKey) throw new Error('Missing GOOGLE_API_KEY in .env');\r\n\r\n    this.indexPath = indexPath;\r\n    this.metaPath = metaPath;\r\n    this.docIdMapPath = docIdMapPath;\r\n    this.metadata = {};\r\n    this.docIdByVectorIdx = [];\r\n\r\n    this.model = new GoogleGenerativeAIEmbeddings({\r\n      apiKey: apiKey,\r\n      modelName: 'models/embedding-001'\r\n    });\r\n\r\n    const dim = 768;\r\n    if (fs.existsSync(this.indexPath)) {\r\n      this.index = IndexFlatL2.read(this.indexPath) as IndexFlatL2;\r\n    } else {\r\n      this.index = new IndexFlatL2(dim);\r\n    }\r\n\r\n    if (fs.existsSync(this.metaPath)) {\r\n      this.metadata = JSON.parse(fs.readFileSync(this.metaPath, 'utf-8'));\r\n    }\r\n\r\n    if (fs.existsSync(this.docIdMapPath)) {\r\n      this.docIdByVectorIdx = JSON.parse(fs.readFileSync(this.docIdMapPath, 'utf-8'));\r\n    }\r\n  }\r\n\r\n  async upsert(docId: string, content: string): Promise<void> {\r\n        // const contentHash = this.getHash(content);\r\n        // if (docId in this.metadata && this.metadata[docId].contentHash === contentHash) {\r\n        //     console.log(`[${docId}] No change detected. Skipping.`);\r\n        //     return;\r\n        // }\r\n        const chunks = this.chunkText(content);\r\n        console.log(\"Creating chunks...\")\r\n        const embeddings = await this.model.embedDocuments(chunks);\r\n        console.log(\"Creating embeddings...\")\r\n        const flatEmbeddings = embeddings.flat();\r\n        this.index.add(flatEmbeddings);\r\n        console.log(\"Adding embeddings...\")\r\n        for (let i = 0; i < embeddings.length; i++) {\r\n            this.docIdByVectorIdx.push(docId);\r\n        }\r\n        console.log(\"Adding embeddings...\")\r\n        this.metadata[docId] = {\r\n            content\r\n        };\r\n        console.log(\"Adding embeddings...\")\r\n        this.save();\r\n        console.log(`[${docId}] Upserted successfully.`);\r\n    }\r\n\r\n  async search(query: string, k = 5): Promise<any[]> {\r\n        const queryVec = await this.model.embedQuery(query);\r\n        const queryArray = queryVec;\r\n        const result = this.index.search(queryArray, k);\r\n        console.log(result);\r\n        const hits = [];\r\n        for (let i = 0; i < result.labels.length; i++) {\r\n            const idx = result.labels[i];\r\n            console.log(idx);\r\n            const docId = this.docIdByVectorIdx[idx];\r\n            console.log(docId);\r\n            // console.log(this.metadata[docId].content);\r\n            if (docId && this.metadata[docId]) {\r\n                hits.push({\r\n                    docId:docId,\r\n                    content: this.metadata[docId].content\r\n                });\r\n            }\r\n        }\r\n        return hits;\r\n  }\r\n\r\n  private ensureDir(filePath: string) {\r\n  const dir = path.dirname(filePath);\r\n  if (!fs.existsSync(dir)) {\r\n    fs.mkdirSync(dir, { recursive: true });\r\n  }\r\n }\r\n\r\n  private save(): void {\r\n  console.log(\"Entering...\");\r\n\r\n  try {\r\n    this.ensureDir(this.indexPath);\r\n    this.index.write(this.indexPath);\r\n  } catch (err) {\r\n    console.error(\"Failed to write index:\", err);\r\n  }\r\n\r\n  try {\r\n    this.ensureDir(this.metaPath);\r\n    fs.writeFileSync(this.metaPath, JSON.stringify(this.metadata, null, 2));\r\n  } catch (err) {\r\n    console.error(\"Failed to write metadata:\", err);\r\n  }\r\n\r\n  try {\r\n    this.ensureDir(this.docIdMapPath);\r\n    fs.writeFileSync(this.docIdMapPath, JSON.stringify(this.docIdByVectorIdx, null, 2));\r\n  } catch (err) {\r\n    console.error(\"Failed to write docId map:\", err);\r\n  }\r\n\r\n  console.log(\"Save complete.\");\r\n}\r\n\r\n\r\n\r\n  async removeDocument(docId: string) {\r\n    if (!(docId in this.metadata)) {\r\n        console.log(`[${docId}] Not found in index. Skipping removal.`);\r\n        return;\r\n    }\r\n\r\n    // Step 1: Identify vector indices to remove\r\n    const indicesToRemove = [];\r\n    for (let i = 0; i < this.docIdByVectorIdx.length; i++) {\r\n        if (this.docIdByVectorIdx[i] === docId) {\r\n            indicesToRemove.push(i);\r\n        }\r\n    }\r\n\r\n    if (indicesToRemove.length === 0) {\r\n        console.log(`[${docId}] No associated vectors found. Only metadata removed.`);\r\n        delete this.metadata[docId];\r\n        this.save();\r\n        return;\r\n    }\r\n\r\n    // Step 2: Remove vectors from FAISS index\r\n    const removedCount = this.index.removeIds(indicesToRemove);\r\n    console.log(`[${docId}] Removed ${removedCount} vectors from FAISS index.`);\r\n\r\n    // Step 3: Remove metadata\r\n    delete this.metadata[docId];\r\n\r\n    // Step 4: Rebuild docIdByVectorIdx (preserving correct order after FAISS shift)\r\n    const removalSet = new Set(indicesToRemove);\r\n    this.docIdByVectorIdx = this.docIdByVectorIdx.filter((_, idx) => !removalSet.has(idx));\r\n\r\n    // Step 5: Save all state\r\n    this.save();\r\n    console.log(`[${docId}] Document fully removed and index state updated.`);\r\n }\r\n\r\n  chunkText(text:string, maxTokens = 500, overlap = 100) {\r\n    const words = text.split(/\\s+/);\r\n    const chunks = [];\r\n    let start = 0;\r\n    while (start < words.length) {\r\n        const end = Math.min(start + maxTokens, words.length);\r\n        chunks.push(words.slice(start, end).join(' '));\r\n        start += maxTokens - overlap;\r\n    }\r\n    return chunks;\r\n}\r\n\r\n}\r\n\r\n// let indexPath = path.resolve(__dirname, '../../index/index.faiss');\r\n// let metaPath = path.resolve(__dirname, '../../index/metadata.json');\r\n// let docIdMapPath = path.resolve(__dirname, '../../index/docIdMap.json');\r\n// function chunkText(text:string, maxTokens = 500, overlap = 100) {\r\n//     const words = text.split(/\\s+/);\r\n//     const chunks = [];\r\n//     let start = 0;\r\n//     while (start < words.length) {\r\n//         const end = Math.min(start + maxTokens, words.length);\r\n//         chunks.push(words.slice(start, end).join(' '));\r\n//         start += maxTokens - overlap;\r\n//     }\r\n//     return chunks;\r\n// }\r\n// const dim = 768;\r\n// let index = fs.existsSync(indexPath)\r\n//   ? IndexFlatL2.read(indexPath)\r\n//   : new IndexFlatL2(dim);\r\n\r\n// let metadata = fs.existsSync(metaPath)\r\n//   ? JSON.parse(fs.readFileSync(metaPath, 'utf-8'))\r\n//   : {};\r\n\r\n// let docIdByVectorIdx: string[] = fs.existsSync(docIdMapPath)\r\n//   ? JSON.parse(fs.readFileSync(docIdMapPath, 'utf-8'))\r\n//   : [];\r\n\r\n// const model = new GoogleGenerativeAIEmbeddings({\r\n//   apiKey: \"AIzaSyA19pwj8bBo95b8ibf0yjnSErRn_CXRFz4\",\r\n//   model: 'models/embedding-001'\r\n// });\r\n\r\n// function save() {\r\n//   index.write(indexPath);\r\n//   fs.writeFileSync(metaPath, JSON.stringify(metadata, null, 2));\r\n//   fs.writeFileSync(docIdMapPath, JSON.stringify(docIdByVectorIdx, null, 2));\r\n// }\r\n\r\n// export default async function (ctx: GSContext, args: PlainObject): Promise<GSStatus> {\r\n//   try {\r\n//     const { docId, content, query, mode = 'upsert', k = 5 } = args;\r\n\r\n//     if (mode === 'upsert') {\r\n//     //   const contentHash = getHash(content);\r\n//     //   if (docId in metadata && metadata[docId].contentHash === contentHash) {\r\n//     //     ctx.childLogger.info(`[${docId}] No change detected. Skipping.`);\r\n//     //     return new GSStatus(true, 200, undefined, { message: 'No update needed.' });\r\n//     //   }\r\n\r\n//       const chunks = chunkText(content);\r\n//       const embeddings = await model.embedDocuments(chunks);\r\n//       const flatEmbeddings = embeddings.flat();\r\n//       index.add(flatEmbeddings);\r\n//       for (let i = 0; i < embeddings.length; i++) {\r\n//         docIdByVectorIdx.push(docId);\r\n//       }\r\n\r\n//       metadata[docId] = { content };\r\n//       save();\r\n\r\n//       return new GSStatus(true, 200, undefined, { message: 'Upserted successfully.', docId });\r\n//     }\r\n\r\n//     if (mode === 'search') {\r\n//       const queryVec = await model.embedQuery(query);\r\n//       const result = index.search(queryVec, k);\r\n//       console.log(result);\r\n//       const hits = [];\r\n//       for (let i = 0; i < result.labels.length; i++) {\r\n//             const idx = result.labels[i];\r\n//             console.log(idx);\r\n//             const docId = docIdByVectorIdx[idx];\r\n//             console.log(docId);\r\n//             // console.log(this.metadata[docId].content);\r\n//             if (docId && metadata[docId]) {\r\n//                 hits.push({\r\n//                     docId:docId,\r\n//                     content: metadata[docId].content\r\n//                 });\r\n//             }\r\n//       }\r\n//       // const hits = result.labels.map((idx: number) => {\r\n//       //   const id = docIdByVectorIdx[idx];\r\n//       //   return {\r\n//       //     docId: id,\r\n//       //     content: metadata[id]?.content,\r\n//       //     chunks: metadata[id]?.chunks\r\n//       //   };\r\n//       // });\r\n\r\n//       return new GSStatus(true, 200, undefined, hits);\r\n//     }\r\n\r\n//     if (mode === 'remove') {\r\n//       if (!(docId in metadata)) {\r\n//         return new GSStatus(true, 404, 'Document not found.');\r\n//       }\r\n\r\n//       // Step 1: Identify vector indices to remove\r\n//       const indicesToRemove = [];\r\n//       for (let i = 0; i < docIdByVectorIdx.length; i++) {\r\n//         if (docIdByVectorIdx[i] === docId) {\r\n//             indicesToRemove.push(i);\r\n//         }\r\n//       }\r\n\r\n//       if (indicesToRemove.length === 0) {\r\n//         console.log(`[${docId}] No associated vectors found. Only metadata removed.`);\r\n//         delete metadata[docId];\r\n//         save();\r\n//         return new GSStatus(true, 200, undefined, { message: 'No associated vectors found. Only metadata removed.', docId });;\r\n//       }\r\n\r\n//       // Step 2: Remove vectors from FAISS index\r\n//       const removedCount = index.removeIds(indicesToRemove);\r\n//       console.log(`[${docId}] Removed ${removedCount} vectors from FAISS index.`);\r\n\r\n//       delete metadata[docId];\r\n\r\n//       const removalSet = new Set(indicesToRemove);\r\n//       docIdByVectorIdx = docIdByVectorIdx.filter((_, idx) => !removalSet.has(idx));\r\n//       save();\r\n\r\n//       return new GSStatus(true, 200, undefined, { message: 'Marked for removal. Rebuild index required.', docId });\r\n//     }\r\n\r\n//     return new GSStatus(false, 400, 'Invalid mode specified.');\r\n//   } catch (err: any) {\r\n//     ctx.logger.error('VectorStore operation failed %o', err);\r\n//     return new GSStatus(false, 500, 'Internal Error', { message: err.message });\r\n//   }\r\n// }\r\n"],"names":["VectorStore","console","log","upsert","docId","content","chunks","chunkText","embeddings","model","embedDocuments","flatEmbeddings","flat","index","add","i","length","docIdByVectorIdx","push","metadata","save","search","query","k","queryVec","embedQuery","queryArray","result","hits","labels","idx","ensureDir","filePath","dir","path","dirname","fs","existsSync","mkdirSync","recursive","indexPath","write","err","error","metaPath","writeFileSync","JSON","stringify","docIdMapPath","removeDocument","indicesToRemove","removedCount","removeIds","removalSet","Set","filter","_","has","text","maxTokens","overlap","words","split","start","end","Math","min","slice","join","resolve","__dirname","apiKey","process","env","GOOGLE_API_KEY","Error","GoogleGenerativeAIEmbeddings","modelName","dim","IndexFlatL2","read","parse","readFileSync"],"mappings":"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"}